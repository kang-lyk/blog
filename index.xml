<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>枯木逢春犹再发，人无两度再少年</title>
    <link>https://kang-lyk.github.io/blog/</link>
    <description>Recent content on 枯木逢春犹再发，人无两度再少年</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 21 Oct 2020 17:05:31 +0800</lastBuildDate>
    
	<atom:link href="https://kang-lyk.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>node.js常用的工具npx、nvm、nrm、pm2</title>
      <link>https://kang-lyk.github.io/blog/post/2020/1021/</link>
      <pubDate>Wed, 21 Oct 2020 17:05:31 +0800</pubDate>
      
      <guid>https://kang-lyk.github.io/blog/post/2020/1021/</guid>
      <description>npx是node自带的强大命令工具 调试安装模块 项目已经安装了ESlint npm i eslint -S 但未全局安装只能在项目根目录下的package.json文件中scripts字段时写命令。
如果想对单个文件制行ESLint命令, eslint file.js又不想全局安装，可以在已安装项目跟目录进行
npx eslint file.js npx会找到根目录下的node_modules/.bin/eslint
避免全局安装模块 npx 可以包下载到临时目录使用，然后自动删除例如：
npx uglify-js@3.1.0 main.js -o ./dist/main.js 使用其他版本的node.js 利用npx的特性，可以使用多个node.js
npx node@10 -v v10.24.1 与下文中nvm不同的是npx是“使用”而不是“安装”，npx命令完成后会把包从临时目录删除下次无法继续使用。
执行github源码 # 执行 Gist 代码 $ npx https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32 # 执行仓库代码 $ npx github:piuccio/cowsay hello -p和-c参数 **-p用于安装多个模块 **
npx -p gulp -p eslint -c用于安装多个模块时将所有命令都用 npx 解释
以下的写完会报错
npx -p gulp -p eslint &amp;#39;gulp | eslint&amp;#39; 可以换成
npx -p gulp -p eslint -c &amp;#39;gulp | eslint&amp;#39; nvm 可以让你要一台机器安装多个版本node.</description>
    </item>
    
    <item>
      <title>用verdaccio搭建npm私服</title>
      <link>https://kang-lyk.github.io/blog/post/2020/1006/</link>
      <pubDate>Tue, 06 Oct 2020 14:39:27 +0800</pubDate>
      
      <guid>https://kang-lyk.github.io/blog/post/2020/1006/</guid>
      <description>为什么要搭建npm私服 npm服务器在国外，国内访问比较慢。虽然有可以代理到淘宝镜像，但有了npm私服后已下包过的包会缓存在公司服务器的npm私服中，获得更快的速度。
公司有些代码不想公开的就需要发npm私包，但那是要收费的，国内公司无法付美元。
这个时候搭一个npm私服就成了不二选择。
安装 全局安装
yarn add verdaccio -g 或
npm i verdaccio -g 局部安装
yarn add verdaccio -s 或
npm i verdaccio -s 启动 已全安装的直接启动
verdaccio 如果是局部安装可以在根目录用npx启动
npx verdaccio 不想每次都进入根目录后再用npx调用可以把verdaccio的安装目录添加到环境变量中去。
启动之后可以通过ip访问http://192.168.3.112:4873 在浏览器直接访问
发布npm包 把源改为已安装的私服
npm set registry http://192.168.3.112:4873 或直接找到.npmrc文件进行修改
registry=http://localhost:4873
推荐使用nvm控制
nrm add myNpm http://192.168.3.112:4873 nrm use myNpm 注册帐号，依次输入用户名和密码
npm adduser 登录,输入用户名密码
npm login 发布包，在项目的根目录运行
npm publish 如果没有修改源可以修改项目根目录的package.josn文件
{ &amp;#34;publishConfig&amp;#34;: { &amp;#34;registry&amp;#34;: &amp;#34;http://192.168.3.112:4873&amp;#34; } } 配置 在启动verdaccio时会打印出一些信息，基中包含配置文件地址
$&amp;gt; verdaccio warn --- config file - /home/.</description>
    </item>
    
    <item>
      <title>开发npm包并发布</title>
      <link>https://kang-lyk.github.io/blog/post/2020/1022/</link>
      <pubDate>Mon, 05 Oct 2020 11:01:55 +0800</pubDate>
      
      <guid>https://kang-lyk.github.io/blog/post/2020/1022/</guid>
      <description>开发 开始一个npm组件得选择一个javascript 模块打包器，rollup是比webpack更适合的存在。vue、Reace等知名框架也同样用rollup.js进行打包。与webpack相比更轻量，打包的代码很干净，没有其他冗余代码。
Babel 是一个工具链，主要用于在旧的浏览器或环境中将 ECMAScript 2015+ 代码转换为向后兼容版本的 JavaScript 代码。如果你的npm包为会在浏览器运行，那么Babel也是你必须安装的包。
新建项目 npm init 依次输入项目名、版本号等信息就会生成一个package.json文件
{ &amp;#34;name&amp;#34;: &amp;#34;lyk_countdown&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;0.1.0&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;倒计时组件&amp;#34;, &amp;#34;keywords&amp;#34;: [&amp;#34;countdown&amp;#34;, &amp;#34;倒计时&amp;#34;], &amp;#34;scripts&amp;#34;: {}, &amp;#34;author&amp;#34;: &amp;#34;luyongkang&amp;#34;, &amp;#34;devDependencies&amp;#34;: {}, &amp;#34;dependencies&amp;#34;: {}, &amp;#34;license&amp;#34;: &amp;#34;ISC&amp;#34; } packag.json文件主要属性：
 version 表明了当前的版本。 name 设置了应用程序/软件包的名称。 description 是应用程序/软件包的简短描述。 main 设置了应用程序的入口点。 scripts 定义了一组可以运行的 node 脚本。 dependencies 设置了作为依赖安装的 npm 软件包的列表。 devDependencies 设置了作为开发依赖安装的 npm 软件包的列表。 engines 设置了此软件包/应用程序在哪个版本的 Node.js 上运行。  &amp;#34;engines&amp;#34;: { &amp;#34;node&amp;#34;: &amp;#34;&amp;gt;= 6.0.0&amp;#34;, &amp;#34;npm&amp;#34;: &amp;#34;&amp;gt;= 3.0.0&amp;#34;, &amp;#34;yarn&amp;#34;: &amp;#34;^0.</description>
    </item>
    
    <item>
      <title>从Promise到async和await</title>
      <link>https://kang-lyk.github.io/blog/post/2020/1004/</link>
      <pubDate>Fri, 28 Feb 2020 06:20:45 +0800</pubDate>
      
      <guid>https://kang-lyk.github.io/blog/post/2020/1004/</guid>
      <description>Promise 是ES6异步编程的一种解决方案,js传统的回调函数和事件更合理更强大。es7标准引入了async/ await函数使得异步操作更加方便。async函数就是 Generator 函数的语法糖。 Generator 语法行为与传统函数完全不同，不容易理解，本文直接会直播跳过 Generator 讲asyn / await。
Promise的使用方法 Promise 对象是一个构造函数，用来生成 Promise 实例，如：
const promise = new Promise(function(resolve, reject) { // ... some code  if (/* 异步操作成功 */){ resolve(value) } else { reject(error) } }) resolve 在异步操作成功时调用,并将异步操作报出的结果作为参数传递出去。
reject 在异步操作失败时调用，并将异步操作报出的错误作为参数传递出去。
Promise 对像的使用方法如下：
promise.then(function(value) { // success }, function(error) { // failure }); 把jq的ajax函数传成Promise对象。
const getList = function(option) { return new Promise((resolve, reject) =&amp;gt; { $.ajax({ url: &amp;#39;/api/news/list&amp;#39;, data: option, success: function(data) { resolve(data) }, error: function(error) { reject(error) } }) }) } 使用方法</description>
    </item>
    
  </channel>
</rss>