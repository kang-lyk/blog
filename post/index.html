<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
<title>Posts - 枯木逢春犹再发，人无两度再少年</title>
<meta name="description"
    content="">


<meta name="viewport" content="width=device-width, initial-scale=1">

<link href="//fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">


<link rel="stylesheet" href="https://kang-lyk.github.io/blog/css/normalize.css">

<link rel="stylesheet" href="https://kang-lyk.github.io/blog/css/skeleton.css">

<link rel="stylesheet" href="https://kang-lyk.github.io/blog/css/custom.css">

<script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/js/all.min.js"></script>




</head>
    <body><nav>
    <label for="drop" class="toggle"><i class="fas fa-bars u-pull-right" aria-hidden="true"></i> <span><i
                class="fas fa-fire" aria-hidden="true"></i>
            枯木</span></label>
    <input type="checkbox" id="drop" />
    <ul class="menu">
        <li><a href="https://kang-lyk.github.io/blog/"><span><i class="fas fa-fire" aria-hidden="true"></i>
                    枯木</span></a></li>
        
        <li class="u-pull-right">
            <a href="https://kang-lyk.github.io/blog/post" class="Members">
                <span> 博文</span>
            </a>
        </li>
        
        <li class="u-pull-right">
            <a href="https://kang-lyk.github.io/blog/" class="Members">
                <span> 首页</span>
            </a>
        </li>
        
    </ul>
</nav>

<div class="section hero">
  <div class="container">
    <div class="row">
      <h1>Posts</h1>
    </div>
  </div>
</div>

<div class="section">
  <div class="container">
    <div class="row">
      
      
      <div class="row">
        <div class="nine columns"> <i class="far fa-calendar"></i> 2021-07-04</div>
        <div class="three columns"> <i class="far fa-clock"></i> Reading Time: 3
          minutes</div>
      </div>
      <h4>
        <a href="https://kang-lyk.github.io/blog/post/2021/0703/" class="h5 d-block my-3">适应不同手机尺寸的解决方案</a>
      </h4>
      <p class="card-text">使用rem做基本单位 移动端必须的head头体
&lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1, maximum-scale=1&#34;&gt; 控制为物理宽度的一倍。然后
html { font-size: 100px; } body { font-size: .14rem; } .box { height: .16rem; } rem属性指的是相对于根元素设置某个元素的字体大小。这些我们只要用js或者css的“媒体查询”控制了根元素的字体大小就很好的适应不同宽度的手机。具体选哪一种可以根据实际情况选择。
js控制根元素字体 在&lt;head&gt;里添加这段js代码
手机淘宝解决方案 这段代码摘自https://main.m.taobao.com/
!function(e, t) { var n = t.documentElement , d = e.devicePixelRatio || 1; function i() { var e = n.clientWidth / 3.75; n.style.fontSize = e + &#34;px&#34; } if (function e() { t.body ? t.body.style.fontSize = &#34;16px&#34; : t.addEventListener(&#34;DOMContentLoaded&#34;, e) }(), i(), e.</p>
      <div class="row">
        <div class="six columns"><a class="button" href="https://kang-lyk.github.io/blog/post/2021/0703/">Read More</a></div>
        <div class="six columns">
          <div class="u-pull-right"> <i class=""></i>
            <span class="category">
              
          </div>
        </div>
      </div>
      
      <div class="row">
        <div class="nine columns"> <i class="far fa-calendar"></i> 2021-05-17</div>
        <div class="three columns"> <i class="far fa-clock"></i> Reading Time: 2
          minutes</div>
      </div>
      <h4>
        <a href="https://kang-lyk.github.io/blog/post/2021/0205/" class="h5 d-block my-3">节流（throttle）与防抖（debounce）</a>
      </h4>
      <p class="card-text">场景 因频繁执行DOM操作，资源加载等行为，导致UI停顿，如：onresize、onscroll、mousemove、mousedown、keydown，文字输入input等事件。
比如每次搜索一下就会向服务器发送一个请求，这样既没有意义，也很浪费资源。
解决方案 实际需求大多为停止改变大小n毫秒后执行后续处理；而其他事件大多数的需求是以一定的频率执行后续处理。针对这两种需求出现了debounce（函数去抖）和throttle（函数节流）两种方式。
节流与防抖： 节流
节流就是控制水的流量。就比如一个持续流水的水龙头，水龙头开到最大的时候很浪费水资源，将水龙头开得小一点，让他每隔300毫秒流出一滴水。而节流就是每隔n的时间调用一次函数，而不是一触发事件就调用一次，这样就会减少资源浪费，比如onscro事件中做图片懒加载。
防抖 A和B说话，A一直bbbbbb，当A持续说了一段时间的话后停止讲话，过了10秒之后，我们判定A讲完了，B开始回答A的话；如果10秒内A又继续讲话，那么我们判定A没讲完，B不响应，等A再次停止后，我们再次计算停止的时间，如果超过10秒B响应，如果没有则B不响应。应用场景如百度的搜索
节流与防抖的区别 节流与防抖的前提都是某个行为持续地触发，不同之处只要判断是要优化到减少它的执行次数还是只执行一次就行。
 节流例子，像dom的拖拽，如果用消抖的话，就会出现卡顿的感觉，因为只在停止的时候执行了一次，这个时候就应该用节流，在一定时间内多次执行，会流畅很多。 防抖例子，像仿百度搜索，就应该用防抖，当我连续不断输入时，不会发送请求；当我一段时间内不输入了，才会发送一次请求；如果小于这段时间继续输入的话，时间会重新计算，也不会发送请求。  debounce（防抖） 防抖分为立即防抖和非立即防抖 最常见的例子就是：搜索
非立即防抖：触发事件后函数不会立即执行，而是在n秒之后执行，如果n秒之内又触发了事件，则会重新计算函数执行时间。 立即防抖：触发事件后函数会立即执行，然后n秒内不触发事件才会执行函数的效果
非立即防抖
在wait参数指定的时间之后执行
function debounce(func, wait) { timeout = null; return function () { const context = this; const args = arguments; timeout &amp;&amp; clearTimeout(timeout); timeout = setTimeout(function () { func.apply(context, args) }, wait); } } 立即防抖
立即执行，但在wait参数指定的时间内不会再执行。
function debounce(func, wait) { let timeout = null; return function () { if (timeout) clearTimeout(timeout); const callNow = !</p>
      <div class="row">
        <div class="six columns"><a class="button" href="https://kang-lyk.github.io/blog/post/2021/0205/">Read More</a></div>
        <div class="six columns">
          <div class="u-pull-right"> <i class=""></i>
            <span class="category">
              
          </div>
        </div>
      </div>
      
      <div class="row">
        <div class="nine columns"> <i class="far fa-calendar"></i> 2020-10-25</div>
        <div class="three columns"> <i class="far fa-clock"></i> Reading Time: 2
          minutes</div>
      </div>
      <h4>
        <a href="https://kang-lyk.github.io/blog/post/2020/1025/" class="h5 d-block my-3">mock.js+koa2作一个简单的mockServe</a>
      </h4>
      <p class="card-text">mock.js是阿里出品的有于拦截AJAX接口请求生成随机数据的库。在已提供接口文档的情况下，用mock.js生接口请求数据，而不用等待服务端的同伙给测试接口，方便并行开发。
以前在研究 ant-design pro时发现它所使用的react角手架DvaJS支持mock.js（现在推荐使用Umi），
在mock目录编辑文件如 /mock/api.js 的内容
export default { // 支持值为 Object 和 Array  &#39;GET /api/users&#39;: { users: [1, 2] }, // GET 可忽略  &#39;/api/users/1&#39;: { id: 1 }, // 支持自定义函数，API 参考 express@4  &#39;POST /api/users/create&#39;: (req, res) =&gt; { // 添加跨域请求头  res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;); res.end(&#39;ok&#39;); } } 然后访问 /api/users 就能得到 { users: [1,2] } 的响应。
vue版本的ant-design是没有Umi这样的角手架，只能用vue-cli了。vue-cli可不是阿里的，没有自带mock.js。
当然这并不影响我们把mock.js加入进去。
//vue.config.js const mock = require(&#39;./mock&#39;) { devServer: { // 环境变量MOCK决定是否开启MOCK  before: process.</p>
      <div class="row">
        <div class="six columns"><a class="button" href="https://kang-lyk.github.io/blog/post/2020/1025/">Read More</a></div>
        <div class="six columns">
          <div class="u-pull-right"> <i class=""></i>
            <span class="category">
              
          </div>
        </div>
      </div>
      
      <div class="row">
        <div class="nine columns"> <i class="far fa-calendar"></i> 2020-10-21</div>
        <div class="three columns"> <i class="far fa-clock"></i> Reading Time: 2
          minutes</div>
      </div>
      <h4>
        <a href="https://kang-lyk.github.io/blog/post/2020/1021/" class="h5 d-block my-3">node.js常用的工具npx、nvm、nrm、pm2</a>
      </h4>
      <p class="card-text">npx是node自带的强大命令工具 调试安装模块 项目已经安装了ESlint npm i eslint -S 但未全局安装只能在项目根目录下的package.json文件中scripts字段时写命令。
如果想对单个文件制行ESLint命令, eslint file.js又不想全局安装，可以在已安装项目跟目录进行
npx eslint file.js npx会找到根目录下的node_modules/.bin/eslint
避免全局安装模块 npx 可以包下载到临时目录使用，然后自动删除例如：
npx uglify-js@3.1.0 main.js -o ./dist/main.js 使用其他版本的node.js 利用npx的特性，可以使用多个node.js
npx node@10 -v v10.24.1 与下文中nvm不同的是npx是“使用”而不是“安装”，npx命令完成后会把包从临时目录删除下次无法继续使用。
执行github源码 # 执行 Gist 代码 $ npx https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32 # 执行仓库代码 $ npx github:piuccio/cowsay hello -p和-c参数 **-p用于安装多个模块 **
npx -p gulp -p eslint -c用于安装多个模块时将所有命令都用 npx 解释
以下的写完会报错
npx -p gulp -p eslint &#39;gulp | eslint&#39; 可以换成
npx -p gulp -p eslint -c &#39;gulp | eslint&#39; nvm 可以让你要一台机器安装多个版本node.</p>
      <div class="row">
        <div class="six columns"><a class="button" href="https://kang-lyk.github.io/blog/post/2020/1021/">Read More</a></div>
        <div class="six columns">
          <div class="u-pull-right"> <i class=""></i>
            <span class="category">
              
          </div>
        </div>
      </div>
      
      <div class="row">
        <div class="nine columns"> <i class="far fa-calendar"></i> 2020-10-06</div>
        <div class="three columns"> <i class="far fa-clock"></i> Reading Time: 1
          minute</div>
      </div>
      <h4>
        <a href="https://kang-lyk.github.io/blog/post/2020/1006/" class="h5 d-block my-3">用verdaccio搭建npm私服</a>
      </h4>
      <p class="card-text">为什么要搭建npm私服 npm服务器在国外，国内访问比较慢。虽然有可以代理到淘宝镜像，但有了npm私服后已下包过的包会缓存在公司服务器的npm私服中，获得更快的速度。
公司有些代码不想公开的就需要发npm私包，但那是要收费的，国内公司无法付美元。
这个时候搭一个npm私服就成了不二选择。
安装 全局安装
yarn add verdaccio -g 或
npm i verdaccio -g 局部安装
yarn add verdaccio -s 或
npm i verdaccio -s 启动 已全安装的直接启动
verdaccio 如果是局部安装可以在根目录用npx启动
npx verdaccio 不想每次都进入根目录后再用npx调用可以把verdaccio的安装目录添加到环境变量中去。
启动之后可以通过ip访问http://192.168.3.112:4873 在浏览器直接访问
发布npm包 把源改为已安装的私服
npm set registry http://192.168.3.112:4873 或直接找到.npmrc文件进行修改
registry=http://localhost:4873
推荐使用nvm控制
nrm add myNpm http://192.168.3.112:4873 nrm use myNpm 注册帐号，依次输入用户名和密码
npm adduser 登录,输入用户名密码
npm login 发布包，在项目的根目录运行
npm publish 如果没有修改源可以修改项目根目录的package.josn文件
{ &#34;publishConfig&#34;: { &#34;registry&#34;: &#34;http://192.168.3.112:4873&#34; } } 配置 在启动verdaccio时会打印出一些信息，基中包含配置文件地址</p>
      <div class="row">
        <div class="six columns"><a class="button" href="https://kang-lyk.github.io/blog/post/2020/1006/">Read More</a></div>
        <div class="six columns">
          <div class="u-pull-right"> <i class=""></i>
            <span class="category">
              
          </div>
        </div>
      </div>
      
      <div class="row">
        <div class="nine columns"> <i class="far fa-calendar"></i> 2020-10-05</div>
        <div class="three columns"> <i class="far fa-clock"></i> Reading Time: 5
          minutes</div>
      </div>
      <h4>
        <a href="https://kang-lyk.github.io/blog/post/2020/1022/" class="h5 d-block my-3">开发npm包并发布</a>
      </h4>
      <p class="card-text">开发 开始一个npm组件得选择一个javascript 模块打包器，rollup是比webpack更适合的存在。vue、Reace等知名框架也同样用rollup.js进行打包。与webpack相比更轻量，打包的代码很干净，没有其他冗余代码。
Babel 是一个工具链，主要用于在旧的浏览器或环境中将 ECMAScript 2015+ 代码转换为向后兼容版本的 JavaScript 代码。如果你的npm包为会在浏览器运行，那么Babel也是你必须安装的包。
新建项目 npm init 依次输入项目名、版本号等信息就会生成一个package.json文件
{ &#34;name&#34;: &#34;lyk_countdown&#34;, &#34;version&#34;: &#34;0.1.0&#34;, &#34;description&#34;: &#34;倒计时组件&#34;, &#34;keywords&#34;: [&#34;countdown&#34;, &#34;倒计时&#34;], &#34;scripts&#34;: {}, &#34;author&#34;: &#34;luyongkang&#34;, &#34;devDependencies&#34;: {}, &#34;dependencies&#34;: {}, &#34;license&#34;: &#34;ISC&#34; } packag.json文件主要属性：
 version 表明了当前的版本。 name 设置了应用程序/软件包的名称。 description 是应用程序/软件包的简短描述。 main 设置了应用程序的入口点。 scripts 定义了一组可以运行的 node 脚本。 dependencies 设置了作为依赖安装的 npm 软件包的列表。 devDependencies 设置了作为开发依赖安装的 npm 软件包的列表。 engines 设置了此软件包/应用程序在哪个版本的 Node.js 上运行。  &#34;engines&#34;: { &#34;node&#34;: &#34;&gt;= 6.0.0&#34;, &#34;npm&#34;: &#34;&gt;= 3.0.0&#34;, &#34;yarn&#34;: &#34;^0.</p>
      <div class="row">
        <div class="six columns"><a class="button" href="https://kang-lyk.github.io/blog/post/2020/1022/">Read More</a></div>
        <div class="six columns">
          <div class="u-pull-right"> <i class=""></i>
            <span class="category">
              
          </div>
        </div>
      </div>
      
      <div class="row">
        <div class="nine columns"> <i class="far fa-calendar"></i> 2020-02-28</div>
        <div class="three columns"> <i class="far fa-clock"></i> Reading Time: 3
          minutes</div>
      </div>
      <h4>
        <a href="https://kang-lyk.github.io/blog/post/2020/1004/" class="h5 d-block my-3">从Promise到async和await</a>
      </h4>
      <p class="card-text">Promise 是ES6异步编程的一种解决方案,js传统的回调函数和事件更合理更强大。es7标准引入了async/ await函数使得异步操作更加方便。async函数就是 Generator 函数的语法糖。 Generator 语法行为与传统函数完全不同，不容易理解，本文直接会直播跳过 Generator 讲asyn / await。
Promise的使用方法 Promise 对象是一个构造函数，用来生成 Promise 实例，如：
const promise = new Promise(function(resolve, reject) { // ... some code  if (/* 异步操作成功 */){ resolve(value) } else { reject(error) } }) resolve 在异步操作成功时调用,并将异步操作报出的结果作为参数传递出去。
reject 在异步操作失败时调用，并将异步操作报出的错误作为参数传递出去。
Promise 对像的使用方法如下：
promise.then(function(value) { // success }, function(error) { // failure }); 把jq的ajax函数传成Promise对象。
const getList = function(option) { return new Promise((resolve, reject) =&gt; { $.ajax({ url: &#39;/api/news/list&#39;, data: option, success: function(data) { resolve(data) }, error: function(error) { reject(error) } }) }) } 使用方法</p>
      <div class="row">
        <div class="six columns"><a class="button" href="https://kang-lyk.github.io/blog/post/2020/1004/">Read More</a></div>
        <div class="six columns">
          <div class="u-pull-right"> <i class=""></i>
            <span class="category">
              
          </div>
        </div>
      </div>
      
    </div>
    <hr>
  </div>
</div>

<footer>
    <span class="copyright">
         &copy; 2021 
        <a href="https://github.com/aanupam23/hugo-sugoi" title="hugo-sugoi" alt="hugo-sugoi" target="_blank">Hugo-Sugoi</a>
    </span>
</footer></body>
</html>
